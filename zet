#!/bin/bash


(( BASH_VERSINFO[0] < 4 )) && echo "Bash 4+ required." && exit 1


# -------------------------------------------------
# ---- configuration settings for your zet --------
# -------------------------------------------------

ZET_EDITOR=$EDITOR
ZET_VIEWER=$VIEWER
PUBLIC=$ZETDIR
PRIVATE=$ZETDIR_PRIVATE
OPTION=$PUBLIC
BASE_DIR=$ZET
TWEEPY_CONF="$BASE_DIR/util/tweepy.conf"
GIT_HOST="$GITHUB_URL/$(basename $OPTION)"
AWS_CREDS="$HOME/.aws/credentials"
WEBSITE_LOCAL_DIR="$REPOS/eliotkhachi.dev"
WEBSITE_BUCKET_NAME=$WEBSITE_BUCKET_NAME
WEBSITE_CLOUDFRONT_DISTRIBUTION_ID=$WEBSITE_CLOUDFRONT_DISTRIBUTION_ID

r='\e[31m' # red
g='\e[32m' # green
y='\e[33m' # yellow
b='\e[34m' # blue
p='\e[35m' # purple
a='\e[36m' # aqua
w='\e[37m' # white
x='\e[0m'  # reset
z='\e[30m' # black



# -----------------------------------------
# ----------- commands for zet ------------
# -----------------------------------------

## returns all zettels from the session directory
x_all() {
    local dir="$(x_dir)"
    ls $dir | grep -Ev '.md$|.json$|.css$|.html$|.sh$'
}

## configures twitter api for python
x_configure_tweepy() {
    read -p "Would you like to configure your zettelkasten for use with twitter? (y/n): " configure
    if [[ "$configure" == "n" || "$configure" == "N" ]]; then
        return 1
    fi

    if [[ "$configure" != "y" && "$configure" != "Y" ]]; then
        echo "ERROR: input must be (y/n)"
        return 1
    fi
    printf "\n"

    while true; do
        echo "================================"
        echo "Press CTRL+C at any time to exit"
        echo "================================"
        printf "\n"
        read -p "Enter your consumer key: " consumer_key
        read -p "Enter your consumer secret: " consumer_secret
        read -p "Enter your access token: " access_token
        read -p "Enter your access token secret: " access_token_secret
        printf "\n"

        printf "Current configurations:\nconsumer_key=%s\nconsumer_secret=%s\naccess_token=%s\naccess_token_secret=%s\n" "$consumer_key" "$consumer_secret" "$access_token" "$access_token_secret"
        printf "\n"

        while true; do
            read -p "Satisfied with current configuration? (y/n): " confirm

            if [[ "$confirm" == "y" || "$confirm" == "Y" ]]; then
                echo -ne "consumer_key=%s\nconsumer_secret=%s\naccess_token=%s\naccess_token_secret=%s\n" "$consumer_key" "$consumer_secret" "$access_token" "$access_token_secret" > $TWEEPY_CONF
                return 0
            fi

            if [[ "$confirm" == "n" || "$confirm" == "N" ]]; then
                break
            fi
            echo "WARN: input must be (y/n)"
        done
        printf "\n\n"
    done
}

## creates a new zettel in the session directory & pushes to remote repo after wq
x_create() {
    if [[ "$#" -lt 1 ]]; then
        exit 1;
    fi
    # create zettel directory, readme, and title the readme 
    local title="$*"
    local dir readme datetime
    datetime="$(x_isomin)"
    dir="$(x_dir)/$datetime"
    readme="$dir/README.md"
    mkdir -p "$dir"
    printf "%s\n\n%s\n" "# $title" "## Tags" > "$readme"
    
    ## open editor
    "$ZET_EDITOR" "$readme"
    cd "$dir" &>/dev/null
    [[ -s "$dir/README.md" ]] || return 1
    line=$(head -1 "$dir/README.md" | sed 's/^# //')
    test -n "$line"
    
    echo "Committing: $line"
    $(x_push $line)

    if [[ -f "$TWEEPY_CONF" ]]; then
        echo "Updating Zettel Mappings..."
        x_zettel_mapping
        x_zettel_repository "$datetime"
    fi

    if [[ "$OPTION" == "$PUBLIC" ]]; then
        x_create_html "$readme"
    fi
    x_update_zettels_json
}

x_delete() {
    local dir="$(x_dir)"
    # Loop through all arguments provided
    for zettel in "$@"; do
        # Delete directory if in publicZk
        if [ -d "$dir/$zettel" ]; then
	        rm -rf "$dir/$zettel"
            echo "$(basename $zettel) has been deleted from $OPTION."
        else
            echo "$(basename $zettel) does not exist in $OPTION."
            echo "Usage: $@ should be zettel ids."
        fi
        # Delete html if in eliotkhachi.dev/zettelkasten
        if [ -f "$WEBSITE_LOCAL_DIR/zettelkasten/$(basename $zettel).html" ]; then
            rm -rf "$WEBSITE_LOCAL_DIR/zettelkasten/$(basename $zettel).html"
            echo "$(basename $zettel).html has been deleted from $WEBSITE_LOCAL_DIR/zettelkasten/."
        else
            echo "$(basename $zettel).html does not exist in $WEBSITE_LOCAL_DIR/zettelkasten."
            echo "Usage: $@ should be zettel ids."
        fi

        if [[ "$OPTION" == "$PUBLIC" ]]; then
            aws s3 rm "s3://$WEBSITE_BUCKET_NAME/zettelkasten/$(basename $zettel).html"
            aws cloudfront create-invalidation --distribution-id $WEBSITE_CLOUDFRONT_DISTRIBUTION_ID --paths="/zettelkasten/$(basename $zettel).html" &> /dev/null
        fi 
    done
    x_update_zettels_json
}

##  sets the session directory to OPTION
x_dir() {
	local dir="$OPTION"
	mkdir -p "$dir" && echo "$dir"
}

## edits a zettel and pushes it to public repo
x_edit() {
    readarray -t directories <<< "$(x_all)"
    if [[ " ${directories[*]} " =~ " $1 " ]]; then
        local dir="$(x_dir)/$1"
        readme="$dir/README.md"
        "$ZET_EDITOR" "$readme"
        cd "$dir" &>/dev/null
        [[ -s "$dir/README.md" ]] || return 1
        line="$(head -1 "$dir/README.md" | sed 's/^# //') (Updated: $(date -u))"
        test -n "$line"
        echo "Committing: $line"
        $(x_push $line)

        if [[ -f "$TWEEPY_CONF" ]]; then
            echo "Updating Zettel Mappings..."
            x_zettel_mapping
            x_zettel_repository "$datetime"
        fi

        if [[ "$OPTION" == "$PUBLIC" ]]; then
            x_create_html "$readme"
        fi
        x_update_zettels_json
    else
        echo "Error: Could not find $1 in $OPTION"
    fi
}

## exits zk
x_exit() {
  echo "Exiting zet..."
  exit 0
}

## show all zettels containing a matching tag; --nocolor option to avoid colors
x_show() {
    local tag="#$1"
    local dir="$(x_dir)"
    if [[ "$1" == "--nocolor" ]]; then
        tag="#$2"
        read -r a y x <<< $(echo "" "" "")
    fi
    readarray -t directories <<< "$(x_all)"
    for i in "${directories[@]}"; do
        if [[ -d "$dir/$i" ]]; then
            readarray -t tags <<< "$(tail -1 $dir/$i/README.md | tr ' ' '\n')"
            for j in "${tags[@]}"; do
                if [[ $j == $tag ]]; then
                    echo -ne "$a$i$x - $y$(head -1 "$dir/$i/README.md" | sed 's/^# //')$x\n" 
                fi
            done
        fi
    done 
}

## returns the current UTC date time as YYYYMMDDHHMM
x_isomin() { date -u +%Y%m%d%H%M ; }

## echoes the markdown to link a given zettel
## Easy to get an id  -->  zet link $(zet show --nocolor foo | grep bar | sed 's/\s.*//')
x_link() {
    readarray -t directories <<< "$(x_all)"
    if [[ " ${directories[*]} " =~ " $1 " ]]; then
        # link="[$(head -1 "$(x_dir)/$1/README.md" | sed 's/^# //')]($GIT_HOST/tree/main/$1)"
        link="[$(head -1 "$(x_dir)/$1/README.md" | sed 's/^# //')](../$1)"
        echo "$link"
    fi
}

x_snip() {
    # init image location
    image_loc="$WEBSITE_LOCAL_DIR/resources/zettel-images/$(date | sed 's/ /_/g').png"

    if [[ "$1" == "pc" ]]; then
        # screenshot desktop area and save image
        gnome-screenshot -ap -f $image_loc
    elif [[ "$1" == "rm" ]]; then
        # screenshot reMarkable tablet and save image
        reSnap -s $REMARKABLE_IP -n -o $image_loc &> /dev/null
    elif [[ "$1" == "select" ]]; then
        # pick an image or gif from your computer
        cp "$(zenity --file-selection --file-filter='Image files | *.png *.jpg *.gif')" $image_loc
    elif [[ "$1" == "ipad" ]]; then
        echo Not yet implemented...
    else
        echo "invalid usage: -h or --help for help"
        exit 0
    fi
    # upload image to s3
    x_upload "resources/zettel-images/$(basename $image_loc)"

    # echo link to the s3 object
    echo "![image](https://www.eliotkhachi.dev/resources/zettel-images/$(basename $image_loc))"
}

## post a zettelkasten link to twitter
x_post() {
    local rc
    if [[ ! -f "$TWEEPY_CONF" ]]; then
      x_configure_tweepy
      rc="$?"
      [[ "$rc" == 0 ]] || x_exit
    fi
    readarray -t directories <<< "$(x_all)"
    if [[ " ${directories[*]} " =~ " $1 " ]]; then
        local zettel post hashtags
        zettel="$(x_dir)/$1/README.md"
        post=$(head -1 $zettel | sed 's/^# //')
        hashtags=$(tail -1 $zettel)
        url="$GIT_HOST/tree/main/$1"
        $BASE_DIR/util/tweet "$post" "$hashtags" "$url"
    fi
}

## pulls zettelkasten from respective remote repo
x_pull() {
    local dir="$(x_dir)"
    cd "$dir" &>/dev/null
    git pull
}

## pushes zettelkasten changes to respective remote repo
x_push() {
    if [[ "$OPTION" == "$PUBLIC" ]]; then
        local dir="$(x_dir)"
        cd "$dir" &>/dev/null
        git add -A "$dir" &>/dev/null
        if [[ -n "$*" ]]; then
            git commit -m "$*" &>/dev/null
        else
            git commit -m "Updated Zettelkasten: $(date -u)" &>/dev/null
        fi
        git push
    fi
}

## reads the contents of a given zettel
x_read() {
    if [[ "$OPTION" == "$PUBLIC" ]]; then
        readarray -t directories <<< "$(x_all)"
        if [[ " ${directories[*]} " =~ " $1 " ]]; then
	    	xdg-open $GIT_HOST/tree/main/$1 2> /dev/null
            # firefox $OPTION/$1/README.md
        fi
    else
        view $OPTION/$1/README.md
    fi
}

## Sync zettels
x_s3_sync() {
    if [ "$OPTION" != "$PUBLIC" ]; then return; fi
    local s3_bucket="s3://zettels-repository"
    if [ -f "$AWS_CREDS" ]; then
        for file_path in $OPTION/*; do
          local file=$(basename ${file_path})
          if ! [[ "$file" =~ ^[0-9] ]]; then continue; fi
          aws s3 cp $file_path/README.md $s3_bucket/$file.md
        done
    fi
}

## returns all tags from a given zettel
x_tags(){
    local dir readme
    dir="$(x_dir)/$1"
    readme="$dir/README.md"
    tail -1 $readme
}

## print the registry object from zettels.json
x_topics() {
    if ! command -v jq &>/dev/null; then
        echo "Error: jq is not installed. Please run \`sudo apt install jq\` before running this command."
        exit 1
    fi

    jq '.registry' $OPTION/zettels.json
}

## updates zettel whitelist
x_whitelist() {
    if [ -f "$AWS_CREDS" ]; then
        $BASE_DIR/util/modify_zettel_whitelist
    fi
}

## show all zettels to the user in a friendly format
x_zk() {
    local dir="$(x_dir)"
    for i in $(ls $dir | grep -Ev '.md|.json'); do
        local dir="$(x_dir)/$i"
        readme="$dir/README.md"
        msg=$(cat "$readme" | head -n 1 | sed 's/^#\s//')
        tags=$(x_tags $i)
        year="${i:0:4}"
        month="${i:4:2}"
        day="${i:6:2}"
        echo -ne "$a$month/$day/$year$x - $y$msg$x ($p$i$x) $g$tags$x\n"
    done | less -r 
}

## creates a tag -> zettels map and stores in a json file
x_zettel_mapping() {
    if [ "$OPTION" != "$PUBLIC" ]; then return; fi
    local s3_bucket="s3://zettel-tag-mappings"
    local mappings_json="$OPTION/MAPPINGS.json"
    $BASE_DIR/util/map_tag_zettel $OPTION
    local git_head=$(jq .git_head $OPTION/MAPPINGS.json -Mr)
    echo "Git head is now at: $git_head"
    if [ -f "$AWS_CREDS" ]; then
        local msg="Pushing MAPPINGS.json to AWS S3"
        echo "$msg"
        aws s3 cp "$mappings_json" "$s3_bucket" &> /dev/null
        msg="Pushing git_head to AWS SSM"
        echo "$msg"
        aws ssm put-parameter --name git_head --value $git_head --overwrite &> /dev/null
    fi
}

## Uploads or updates the zettel to s3
x_zettel_repository() {
    if [ "$OPTION" != "$PUBLIC" ]; then return; fi
    local s3_bucket="s3://zettels-repository"
    if [ -f "$AWS_CREDS" ]; then
        local msg="Pushing Zettel(id=$1) to AWS S3"
        echo "$msg"
        aws s3 cp "$OPTION/$1/README.md" "$s3_bucket/$1.md" &> /dev/null
    fi
}
## recommit all zettels (makes a slight change to each zettel by adding a space at the end of the title)
## PROGRESS
    # Commit message are fixed to reflect zettel titles 
    # Commit dates still aren't fixed
x_fix_commits() { 
    local dir="$(x_dir)"
    cd $dir
    # if [[ "$dir" == "$PUBLIC" ]]; then
        # loop through each directory in your zettelkasten
        for i in $(ls $dir | grep -v '.md'); do
            # parse dir name to store the commit date and time in the format: "2020.11.02 12:00"
            date=$(date -d "${i:0:8} ${i:8:2}:${i:10:2}" +"\"%Y.%m.%d %H:%M\"")

            # parse 1st line of zettel (the title) to get commit message
            readme="$dir/$i/README.md" # get zettel readme
            msg=$(cat "$readme" | head -n 1 | sed 's/^#\s//') # get 1st line, contents after "#"
            sed -i '1s/$/ /' $readme  ## make a slight change to the zettel (add a space at end of title)
            # echo $msg $date
            git commit -a --message="$msg" --date="$date"
        done
    # else 
    #     echo "Recommit aborted. This is a private repository."
    # fi
}

x_create_html() {
    # Check if pandoc is installed
    if ! command -v pandoc &>/dev/null; then
      echo "Error: pandoc is not installed. Please install pandoc before running this script."
      exit 1
    fi

    # Check if the correct number of arguments is provided
    if [ "$#" -ne 1 ]; then
      echo "Usage: $0 input.md"
      exit 1
    fi
    
    # Declare variables
    local dir="$(x_dir)"
    input_file="$1"
    zettel_id=$(basename $(dirname $input_file))
    
    # Check if the input file exists
    if [ ! -f "$input_file" ]; then
      echo "Error in x_create_html: The input file '$input_file' does not exist."
      exit 1
    fi

    # Get title from zettel
    title=$(head -n 1 "$input_file" | sed -n 's/^# //p')
    
    # Declare the file location for the output HTML file 
    output_file="$WEBSITE_LOCAL_DIR/zettelkasten/$zettel_id.html"


    # Convert Markdown to HTML using pandoc
    pandoc -f gfm -t html -F mermaid-filter "$input_file" -o "$output_file" --template="$BASE_DIR/custom_template.html" --metadata title="$title" 
    # pandoc "$input_file" -o "$output_file" --css=https://raw.githubusercontent.com/sindresorhus/github-markdown-css/main/github-markdown.css --template="$BASE_DIR/custom_template.html" --metadata title="$title" 
    
    # Check if the conversion was successful
    if [ $? -eq 0 ]; then
      echo "Conversion successful. HTML file saved as $output_file"
    else
      echo "Error: HTML Conversion failed."
    fi

    # Fix zettel links in html files per $WEBSITE_LOCAL_DIR directory structure:
    sed -i 's#<a href="\.\./\([0-9]\{12\}\)">#<a href="\./\1.html">#g' $output_file

    x_upload "zettelkasten/$zettel_id.html"
}

x_upload() {
    if [[ "$OPTION" == "$PUBLIC" ]]; then
        if [ "$#" -ne 1 ]; then
            echo "Usage: $0 single_input_file"
            exit 1
        fi

        file=$1
    
        # Check if the file exists
        if [ ! -f "$WEBSITE_LOCAL_DIR/$file" ]; then
          echo "Error uploading. The file '$file' does not exist."
          exit 1
        fi
        
        echo "Uploading $WEBSITE_LOCAL_DIR/$file..."
        aws s3 cp --quiet $WEBSITE_LOCAL_DIR/$file s3://$WEBSITE_BUCKET_NAME/$file
        aws cloudfront create-invalidation --distribution-id $WEBSITE_CLOUDFRONT_DISTRIBUTION_ID --paths="/$file" &> /dev/null
    fi
}
    
x_update_zettels_json() {
    echo "Updating zettels.json..."
    cd "$OPTION" || return
    
    # remove current zettels.json
    rm -f zettels.json

    ## CREATE ZETTELS.JSON
    # Initialize empty arrays
    zettels=()
    declare -A registry # associative array for registry (dictionary w/ unique key-value pairs)

    # Loop through each zettel directory
    for dir in *; do
        if [ -d "$dir" ]; then
            id="$dir" # Get the zettel ID
            readme="$OPTION/$dir/README.md" # Get readme from the zettel directory

            # Extract title
            title=$(head -n 1 "$readme" | sed 's/# //g' | sed 's/\(.*\)/"\1"/g')

            # Extract and format tags
            tags=$(tail -n 1 "$readme" | sed 's/## Tags//g' | sed 's/#//g') 
            IFS=' ' read -ra tag_array <<< "$tags"

            zettel_tags=""
            array_length=${#tag_array[@]}
            index=0
            for tag in "${tag_array[@]}"; do 
                registry["\"$tag\""]=1 ## Add unique tags to the registry
                ## Add tags to zettel_tags array
                if [ "$index" -eq "$((array_length-1))" ]; then
                    zettel_tags+="\"$tag\""
                else
                    zettel_tags+="\"$tag\","
                fi 
                ((index++))
            done 


            # Add zettel data to the array
            zettel_data="{\"title\": $title, \"id\": $id, \"tags\": [$zettel_tags]}"
            zettels+=("$zettel_data")
        fi
    done

    # Extract unique tags from the associative array
    unique_tags=("${!registry[@]}")
    # echo ${unique_tags[*]}

    # Sort and rewrite the registry
    registry_sorted=($(for tag in "${unique_tags[@]}"; do echo "$tag"; done | sort))

    # Join and rewrite the data array elements with commas
    IFS=, zettels="${zettels[*]}"
    IFS=, registry="${registry_sorted[*]}"

    # Create the JSON output
    json_output="{\"zettels\": [$zettels], \"registry\": [$registry]}"

    # Write the JSON output to a file
    echo "$json_output" > zettels.json
    echo "$json_output" > "$WEBSITE_LOCAL_DIR/resources/zettels.json"

    x_upload "resources/zettels.json"
}


# -----------------------------------------
# ---- handling command line args ---------
# -----------------------------------------

## parse the zet file and store the commands
while IFS= read -r line; do
    [[ $line =~ ^declare\ -f\ x_ ]] || continue
    COMMANDS+=( "${line##declare -f x_}" )
done < <(declare -F)
mapfile -t COMMANDS < \
    <(LC_COLLATE=C sort < <(printf "%s\n" "${COMMANDS[@]}"))

## check if there is command given
if [[ -n "$1" ]]; then

    ## shows usage of zet
    if [[ "$1" == "--help" || "$1" == "-h" ]]; then
        echo "
        ------------------------------------------------------------------------
        commands:
        ------------------------------------------------------------------------
	all                    :    lists all zettels
	create <<zet>>         :    creates a new zettel
	delete <<zet_id>>      :    deletes a zettel
	dir                    :    gets session directory 
	edit <<zet_id>>        :    make changes to a zettel & push it
	isomin                 :    returns the datetime as YYYYMMDDHHMM (UTC)
	link <<zet_id>>        :    echoes the markdown to link to a zettel
	post <<zet_id>>>       :    tweets zettelkasten title, tags, link
	pull                   :    pulls zettelkasten from remote repo
	push <<message>>       :    commits zettelkasten to remote repo
	read <<zet_id>>        :    prints the contents of a zettel
	show <<zet_tag>        :    shows all zettels that have a matching tag
	tags <<zet_id>>        :    returns all tags associated with zettel
	topics                 :    returns all tags in the registry
	zk                     :    show all zettels in friendly format
        snip <<device>>        :    takes a screenshot - device=pc,rm,select
        ------------------------------------------------------------------------
        options:
        ------------------------------------------------------------------------
        -p || --private        :    sets default session directory to "PRIVATE"
        "
        exit 0
    fi


    ## sets the session directory to $PRIVATE else it defaults to $PUBLIC
    if [[ "$1" == "--private" || "$1" == "-p" ]]; then
        OPTION=$PRIVATE
		GIT_HOST="$GITHUB_URL/$(basename $PRIVATE)"
        shift 1
    fi

    ## no valid options were given, check and see if the arg is a valid command
    declare CMD="$1"; shift

    ## command is not valid, reccomend to look at usage
    if [[ ! "${COMMANDS[*]}" =~ "$CMD" ]]; then
        echo "invalid usage: -h or --help for help"
        exit 0
    fi

    for c in "${COMMANDS[@]}"; do
        ## excecute proper x_command()
        if [[ $c == "$CMD" ]]; then
            "x_$CMD" "$@"
            exit $?
        fi
    done
fi

## no command provided, reccomend to look at usage
echo "invalid usage: -h or --help for help"
